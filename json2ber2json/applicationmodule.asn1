-- $ asn1c -EF CommonModule.asn1 MetadataModule.asn1  RootModule.asn1 TargetsModule.asn1 SnapshotModule.asn1 TimestampModule.asn1 TimeServerModule.asn1 BootloaderModule.asn1 ApplicationModule.asn1 > applicationmodule.asn1
-- To keep asn1ate happy, had to remove:
-- 1. PATTERN constraints on VisibleString.
-- 2. Module definitions in between.

CommonModule DEFINITIONS AUTOMATIC TAGS ::=
BEGIN

RoleType ::= ENUMERATED {
    root(0),
    targets(1),
    snapshot(2),
    timestamp(3)
}

Filename ::= VisibleString (SIZE(1..32))

StrictFilename ::= VisibleString (SIZE(1..32))

BitString ::= BIT STRING (SIZE(1..1024))

OctetString ::= OCTET STRING (SIZE(1..1024))

HexString ::= VisibleString (SIZE(1..1024))

Base64String ::= VisibleString (SIZE(1..1024))

Paths ::= SEQUENCE (SIZE(1..8)) OF Path

Path ::= VisibleString (SIZE(1..32))

URLs ::= SEQUENCE (SIZE(1..8)) OF URL

URL ::= VisibleString (SIZE(1..1024))

Identifier ::= VisibleString (SIZE(1..32))

Natural ::= INTEGER (0..MAX)

Positive ::= INTEGER (1..MAX)

Length ::= Positive

Threshold ::= Positive

Version ::= Positive

UTCDateTime ::= Positive

BinaryData ::= CHOICE {
    bitString	 [0] IMPLICIT BitString,
    octetString	 [1] IMPLICIT OctetString,
    hexString	 [2] IMPLICIT HexString,
    base64String	 [3] IMPLICIT Base64String
}

Hashes ::= SEQUENCE (SIZE(1..8)) OF Hash

Hash ::= SEQUENCE {
    function	 [0] IMPLICIT HashFunction,
    digest	 [1] EXPLICIT BinaryData
}

HashFunction ::= ENUMERATED {
    sha224(0),
    sha256(1),
    sha384(2),
    sha512(3),
    sha512-224(4),
    sha512-256(5),
    ...
}

Keyids ::= SEQUENCE (SIZE(1..8)) OF Keyid

Keyid ::= HexString

Signatures ::= SEQUENCE (SIZE(1..8)) OF Signature

Signature ::= SEQUENCE {
    keyid	 [0] IMPLICIT Keyid,
    method	 [1] IMPLICIT SignatureMethod,
    hash	 [2] IMPLICIT Hash,
    value	 [3] IMPLICIT HexString
}

SignatureMethod ::= ENUMERATED {
    rsassa-pss(0),
    ed25519(1),
    ...
}

PublicKeys ::= SEQUENCE (SIZE(1..8)) OF PublicKey

PublicKey ::= SEQUENCE {
    publicKeyid	 [0] IMPLICIT Keyid,
    publicKeyType	 [1] IMPLICIT PublicKeyType,
    publicKeyValue	 [2] EXPLICIT BinaryData
}

PublicKeyType ::= ENUMERATED {
    rsa(0),
    ed25519(1),
    ...
}

Metadata ::= SEQUENCE {
    signed	 [0] IMPLICIT Signed,
    numberOfSignatures	 [1] IMPLICIT Length,
    signatures	 [2] IMPLICIT Signatures
}

Signed ::= SEQUENCE {
    type	 [0] IMPLICIT RoleType,
    expires	 [1] IMPLICIT UTCDateTime,
    version	 [2] IMPLICIT Positive,
    body	 [3] EXPLICIT SignedBody
}

SignedBody ::= CHOICE {
    rootMetadata	 [0] IMPLICIT RootMetadata,
    targetsMetadata	 [1] IMPLICIT TargetsMetadata,
    snapshotMetadata	 [2] IMPLICIT SnapshotMetadata,
    timestampMetadata	 [3] IMPLICIT TimestampMetadata
}

RootMetadata ::= SEQUENCE {
    numberOfKeys	 [0] IMPLICIT Length,
    keys	 [1] IMPLICIT PublicKeys,
    numberOfRoles	 [2] IMPLICIT Length,
    roles	 [3] IMPLICIT TopLevelRoles,
    ...
}

TopLevelRoles ::= SEQUENCE (SIZE(4)) OF TopLevelRole

TopLevelRole ::= SEQUENCE {
    role	 [0] IMPLICIT RoleType,
    numberOfURLs	 [1] IMPLICIT Length OPTIONAL,
    urls	 [2] IMPLICIT URLs OPTIONAL,
    numberOfKeyids	 [3] IMPLICIT Length,
    keyids	 [4] IMPLICIT Keyids,
    threshold	 [5] IMPLICIT Threshold,
    ...
}

TargetsMetadata ::= SEQUENCE {
    numberOfTargets	 [0] IMPLICIT Length,
    targets	 [1] IMPLICIT Targets,
    delegations	 [2] IMPLICIT TargetsDelegations OPTIONAL,
    ...
}

Targets ::= SEQUENCE (SIZE(1..128)) OF TargetAndCustom

TargetAndCustom ::= SEQUENCE {
    target	 [0] IMPLICIT Target,
    custom	 [1] IMPLICIT Custom OPTIONAL
}

Target ::= SEQUENCE {
    filename	 [0] IMPLICIT Filename,
    length	 [1] IMPLICIT Length,
    numberOfHashes	 [2] IMPLICIT Length,
    hashes	 [3] IMPLICIT Hashes
}

Custom ::= SEQUENCE {
    ecuIdentifier	 [0] IMPLICIT Identifier,
    encryptedTarget	 [1] IMPLICIT Target OPTIONAL,
    encryptedSymmetricKey	 [2] IMPLICIT EncryptedSymmetricKey OPTIONAL,
    ...
}

EncryptedSymmetricKey ::= SEQUENCE {
    encryptedSymmetricKeyType	 [0] IMPLICIT EncryptedSymmetricKeyType,
    encryptedSymmetricKeyValue	 [1] EXPLICIT BinaryData
}

EncryptedSymmetricKeyType ::= ENUMERATED {
    aes128(0),
    aes192(1),
    aes256(2),
    ...
}

TargetsDelegations ::= SEQUENCE {
    numberOfKeys	 [0] IMPLICIT Length,
    keys	 [1] IMPLICIT PublicKeys,
    numberOfRoles	 [2] IMPLICIT Length,
    roles	 [3] IMPLICIT DelegatedTargetsRoles,
    numberOfPrioritizedPathsToRoles	 [4] IMPLICIT Length,
    prioritizedPathsToRoles	 [5] IMPLICIT PrioritizedPathsToRoles
}

DelegatedTargetsRoles ::= SEQUENCE (SIZE(1..8)) OF DelegatedTargetsRole

DelegatedTargetsRole ::= SEQUENCE {
    rolename	 [0] IMPLICIT RoleName,
    filename	 [1] IMPLICIT StrictFilename OPTIONAL,
    numberOfKeyids	 [2] IMPLICIT Length,
    keyids	 [3] IMPLICIT Keyids,
    threshold	 [4] IMPLICIT Threshold
}

RoleNames ::= SEQUENCE (SIZE(1..8)) OF RoleName

RoleName ::= StrictFilename

PrioritizedPathsToRoles ::= SEQUENCE (SIZE(1..8)) OF PathsToRoles

PathsToRoles ::= SEQUENCE {
    numberOfPaths	 [0] IMPLICIT Length,
    paths	 [1] IMPLICIT Paths,
    numberOfRoles	 [2] IMPLICIT Length,
    roles	 [3] IMPLICIT RoleNames,
    terminating	 [4] IMPLICIT BOOLEAN DEFAULT FALSE
}

SnapshotMetadata ::= SEQUENCE {
    numberOfSnapshotMetadataFiles	 [0] IMPLICIT Length,
    snapshotMetadataFiles	 [1] IMPLICIT SnapshotMetadataFiles
}

SnapshotMetadataFiles ::= SEQUENCE (SIZE(1..128)) OF SnapshotMetadataFile

SnapshotMetadataFile ::= SEQUENCE {
    filename	 [0] IMPLICIT StrictFilename,
    version	 [1] IMPLICIT Version,
    ...
}

TimestampMetadata ::= SEQUENCE {
    filename	 [0] IMPLICIT Filename,
    version	 [1] IMPLICIT Version,
    ...
}

SequenceOfNonces ::= SEQUENCE {
    numberOfNonces	 [0] IMPLICIT Length,
    nonces	 [1] IMPLICIT Nonces
}

Nonces ::= SEQUENCE (SIZE(1..128)) OF Nonce

Nonce ::= INTEGER

SequenceOfCurrentTimes ::= SEQUENCE {
    numberOfCurrentTimes	 [0] IMPLICIT Length,
    currentTimes	 [1] IMPLICIT CurrentTimes
}

CurrentTimes ::= SEQUENCE (SIZE(1..128)) OF CurrentTime

CurrentTime ::= SEQUENCE {
    signed	 [0] IMPLICIT NonceAndTimestamp,
    numberOfSignatures	 [1] IMPLICIT Length,
    signatures	 [2] IMPLICIT Signatures
}

NonceAndTimestamp ::= SEQUENCE {
    nonce	 [0] IMPLICIT Nonce,
    timestamp	 [1] IMPLICIT UTCDateTime,
    ...
}

ImageRequest ::= SEQUENCE {
    filename	 [0] IMPLICIT Filename,
    ...
}

VersionReport ::= SEQUENCE {
    nonceForTimeServer	 [0] IMPLICIT Nonce,
    ecuVersionManifest	 [1] IMPLICIT ECUVersionManifest,
    ...
}

ECUVersionManifest ::= SEQUENCE {
    signed	 [0] IMPLICIT ECUVersionManifestSigned,
    signature	 [1] IMPLICIT Signature
}

ECUVersionManifestSigned ::= SEQUENCE {
    ecuIdentifier	 [0] IMPLICIT Identifier,
    previousTime	 [1] IMPLICIT UTCDateTime,
    currentTime	 [2] IMPLICIT UTCDateTime,
    securityAttack	 [3] IMPLICIT VisibleString (SIZE(1..1024)) OPTIONAL,
    installedImage	 [4] IMPLICIT Target,
    ...
}

VehicleVersionManifest ::= SEQUENCE {
    signed	 [0] IMPLICIT VehicleVersionManifestSigned,
    signature	 [1] IMPLICIT Signature
}

VehicleVersionManifestSigned ::= SEQUENCE {
    vehicleIdentifier	 [0] IMPLICIT Identifier,
    primaryIdentifier	 [1] IMPLICIT Identifier,
    numberOfECUVersionManifests	 [2] IMPLICIT Length,
    ecuVersionManifests	 [3] IMPLICIT ECUVersionManifests,
    ...
}

ECUVersionManifests ::= SEQUENCE (SIZE(1..128)) OF ECUVersionManifest

MetadataBroadcast ::= SEQUENCE {
    broadcastGUID	 [0] IMPLICIT INTEGER,
    numberOfMetadataFiles	 [1] IMPLICIT Length
}

MetadataFile ::= SEQUENCE {
    broadcastGUID	 [0] IMPLICIT INTEGER,
    fileNumber	 [1] IMPLICIT Positive,
    filename	 [2] IMPLICIT Filename,
    metadata	 [3] IMPLICIT Metadata
}

ImageFile ::= SEQUENCE {
    filename	 [0] IMPLICIT Filename,
    numberOfBlocks	 [1] IMPLICIT Positive,
    blockSize	 [2] IMPLICIT Positive
}

ImageBlock ::= SEQUENCE {
    filename	 [0] IMPLICIT Filename,
    blockNumber	 [1] IMPLICIT Positive,
    block	 [2] EXPLICIT BinaryData
}

END
